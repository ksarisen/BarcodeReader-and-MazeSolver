#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
/*
IMPORTANT:
Change start row & col (lines  31&32 ) before demonstration
Change target row & col (lines  37&38 ) before demonstration
Change robHeading in robotSolvedMaze (line 227) before demonstration
*/
const int screenHeight = 127;
const int screenWidth = 177;
const int numOfRows = 10;
const int numOfCols = 8;
int robHeading = 0; // 0=North, 1=East, 2=South, 3=West
typedef struct{
	int nWall; // 0 = door, 1 = wall
	int eWall;
	int sWall;
	int wWall;
}cell;
cell maze[numOfRows][numOfCols];
int directionLog [150];
int stepCounter = 0;

//Start
int startRow = 0;
int startcol = 5;
int robRow = startRow;
int robCol = startcol;

//Target
int targetRow = 5;
int targetCol = 4;

void startMove();
void simplifyMaze();
void buildOuterBorders();
void gridDraw();
void drawBot();
void turnRight();
void turnLeft();
void goFwd();
void refreshScreen();
void MazeSim();
void mazeSolverRHF();

//function to move the robot forward one cell
void robotForward(){
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
	sleep(100);
	int blackLineValue=28;
	int yellowLineValue=31;
	int cellLength=630;
	int cellLengthYellow=cellLength-5;
	int lowSpeed=10;
	int highSpeed=15;
	if(robRow < 4){//line track for black lines & light tiles
		setMotorTarget(armMotor, 0, 15);
		waitUntilMotorStop(armMotor);
		setMotorTarget(armMotor, -90, 15); //move arm to the right to begin scanning for line
		waitUntilMotorStop(armMotor);
		int colorValue = getColorReflected(colorSensor);//initialize the sensor to throw first value
		int temp = 0;
		while(temp<=5){
			colorValue = getColorReflected(colorSensor);
			sleep(100);
			temp++;
		}
		while( (getColorReflected(colorSensor) > blackLineValue) && (getMotorEncoder(armMotor) != 90) ){
			setMotorSpeed(armMotor, 5);
		}
		if( getMotorEncoder(armMotor) > 0 ){ //line track with the line to the left of the sensor
			setMotorTarget(armMotor, 0, 15);
			waitUntilMotorStop(armMotor);
			resetMotorEncoder(leftMotor);
			resetMotorEncoder(rightMotor);
			while( getMotorEncoder(leftMotor) < cellLength || getMotorEncoder(rightMotor) < cellLength){
				//drift left
				setMotorSpeed(leftMotor,lowSpeed);
				setMotorSpeed(rightMotor,highSpeed);
				while(getColorReflected(colorSensor) < blackLineValue &&(getMotorEncoder(leftMotor) < cellLength || getMotorEncoder(rightMotor) < cellLength)){
					//dright right
					setMotorSpeed(leftMotor,highSpeed);
					setMotorSpeed(rightMotor,lowSpeed);
				}
			}
			setMotorSpeed(leftMotor,0);
			setMotorSpeed(rightMotor,0);
			waitUntilMotorStop(leftMotor);
			waitUntilMotorStop(rightMotor);
		}
		else{ //line track with the line to the right of the sensor
			setMotorTarget(armMotor, 0, 15);
			waitUntilMotorStop(armMotor);
			resetMotorEncoder(leftMotor);
			resetMotorEncoder(rightMotor);
			while( (getMotorEncoder(leftMotor) < cellLength || getMotorEncoder(rightMotor) < cellLength)){
				//drift right
				setMotorSpeed(leftMotor,highSpeed);
				setMotorSpeed(rightMotor,lowSpeed);
				while(getColorReflected(colorSensor) < blackLineValue && (getMotorEncoder(leftMotor) < cellLength || getMotorEncoder(rightMotor) < cellLength)){
					//dright left
					setMotorSpeed(leftMotor, lowSpeed);
					setMotorSpeed(rightMotor, highSpeed);
				}
			}
			setMotorSpeed(leftMotor,0);
			setMotorSpeed(rightMotor,0);
			waitUntilMotorStop(leftMotor);
			waitUntilMotorStop(rightMotor);
		}
	}
	else{//line track for yellow lines and dark tiles
		setMotorTarget(armMotor, 0, 15);
		waitUntilMotorStop(armMotor);
		setMotorTarget(armMotor, -90, 15); //move arm to the right to begin scanning for line
		waitUntilMotorStop(armMotor);
		int colorValue = getColorReflected(colorSensor);//initialize the sensor to throw first value
		int temp = 0;
		while(temp<=5){
			colorValue = getColorReflected(colorSensor);
			sleep(100);
			temp++;
		}
		while( (getColorReflected(colorSensor) < yellowLineValue) && (getMotorEncoder(armMotor) != 90) ){
			setMotorSpeed(armMotor, 5);
		}
		if( getMotorEncoder(armMotor) > 0 ){ //line track with the line to the left of the sensor
			setMotorTarget(armMotor, 0, 15);
			waitUntilMotorStop(armMotor);
			resetMotorEncoder(leftMotor);
			resetMotorEncoder(rightMotor);
			while( (getMotorEncoder(leftMotor) < cellLengthYellow || getMotorEncoder(rightMotor) < cellLengthYellow)){
				//drift left
				setMotorSpeed(leftMotor,lowSpeed);
				setMotorSpeed(rightMotor,highSpeed);
				while(getColorReflected(colorSensor) > yellowLineValue && (getMotorEncoder(leftMotor) < cellLengthYellow || getMotorEncoder(rightMotor) < cellLengthYellow)){
					//dright right
					setMotorSpeed(leftMotor,highSpeed);
					setMotorSpeed(rightMotor,lowSpeed);
				}
			}
			setMotorSpeed(leftMotor,0);
			setMotorSpeed(rightMotor,0);
			waitUntilMotorStop(leftMotor);
			waitUntilMotorStop(rightMotor);
		}
		else{ //line track with the line to the right of the sensor
			setMotorTarget(armMotor, 0, 15);
			waitUntilMotorStop(armMotor);
			resetMotorEncoder(leftMotor);
			resetMotorEncoder(rightMotor);
			while( getMotorEncoder(leftMotor) < cellLengthYellow || getMotorEncoder(rightMotor) < cellLengthYellow){
				//drift right
				setMotorSpeed(leftMotor,highSpeed);
				setMotorSpeed(rightMotor,lowSpeed);
				while(getColorReflected(colorSensor) > yellowLineValue && (getMotorEncoder(leftMotor) < cellLengthYellow || getMotorEncoder(rightMotor) < cellLengthYellow)){
					//dright left
					setMotorSpeed(leftMotor,lowSpeed);
					setMotorSpeed(rightMotor,highSpeed);
				}
			}
			setMotorSpeed(leftMotor,0);
			setMotorSpeed(rightMotor,0);
			waitUntilMotorStop(leftMotor);
			waitUntilMotorStop(rightMotor);
		}
	}
	if (robHeading==0) { // Going Fwd North
		robRow++;
	}
	else if (robHeading==1) { // Going Fwd East
		robCol++;
	}
	else if (robHeading==2) { // Going Fwd South
		robRow--;
	}
	else if (robHeading==3) { // Going Fwd West
		robCol--;
	}
	else {
		robRow = 99;
		robCol = 99;
	}
	eraseDisplay();//quickly shows current position in the maze
	displayCenteredTextLine(6, "current row: %d", robRow);
	displayCenteredTextLine(8, "current col: %d", robCol);
	displayCenteredTextLine(10, "Robot facing: %d", robHeading);
	sleep(500);
}
void robotRight(){
	resetMotorEncoder(rightMotor);
	resetMotorEncoder(leftMotor);
	setMotorTarget(rightMotor, -270, 20);
	setMotorTarget(leftMotor, 270, 20);
	waitUntilMotorStop(rightMotor);
	waitUntilMotorStop(leftMotor);
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
	if (robHeading < 3){
		robHeading++;
	}
	else robHeading=0;
}
void robotLeft(){
	resetMotorEncoder(rightMotor);
	resetMotorEncoder(leftMotor);
	setMotorTarget(rightMotor, 273, 20);
	setMotorTarget(leftMotor, -273, 20);
	waitUntilMotorStop(rightMotor);
	waitUntilMotorStop(leftMotor);
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
	if (robHeading > 0){
		robHeading--;
	}
	else robHeading=3;
}
void robotSolvedMaze(){
	robRow=startRow;
	robCol=startcol;
	robHeading=0; //Change heading before demonstration
	while(robRow != targetRow || robCol != targetCol){
		for(int i = 0; i < stepCounter; i++){
			if(directionLog[i] >= 0){
				while(directionLog[i] != robHeading){
					if(directionLog[i] > robHeading && directionLog[i] - robHeading != 3){
						robotRight();
					}
					else if(directionLog[i] == 0 && robHeading == 3)
						robotRight();
					else{
						robotLeft();
					}
				}
				robotForward();
				refreshScreen();//draws current position status in the maze on screen
				sleep(1000);
			}
		}
	}
	if(robRow == targetRow && robCol == targetCol){//runs celebration only if the robot has reached the target
	eraseDisplay();
  displayCenteredTextLine(8, "Maze Solved!");
  	for(int i=0;i<2;i++){
  		playImmediateTone(100, 5);
      ev3StopSound();
      playSound(soundLowBuzzShort);//plays noise indicating the robot is at the right spot
			sleep(1500);
  		clearSounds();
  	}

	}
}
///////////////////////////////////////////
///////////////////MAIN////////////////////
///////////////////////////////////////////
task main(){
	buildOuterBorders();
	MazeSim();
	displayCenteredBigTextLine(2, "Algortihm starts");
	displayCenteredBigTextLine(4, "starting cell");
	displayCenteredBigTextLine(6, "row %d	column	%d", robRow,robCol);
	displayCenteredBigTextLine(8, "target cell");
	displayCenteredBigTextLine(10, "row %d	column	%d", targetRow,targetCol);
	sleep(1500);
	playSound(soundFastUpwardTones);//signals the start of solving
	mazeSolverRHF();
	sleep(1000);
	playSound(soundFastUpwardTones);//signals the robot will move in shortest path
	playSound(soundFastUpwardTones);
	robotSolvedMaze();
}
void mazeSolverRHF(){//solves the maze using the right hand on the wall rule
	turnRight();
	while((robCol != targetCol) || (robRow != targetRow) ){
		switch(robHeading){
		case 0:// facing north
			if(maze[robRow][robCol].nWall == 1){
				turnLeft();
				continue;
			}
			break;
		case 1: // facing east
			if(maze[robRow][robCol].eWall == 1){
				turnLeft();
				continue;
			}
			break;
		case 2:// facing south
			if(maze[robRow][robCol].sWall == 1){
				turnLeft();
				continue;
			}
			break;
		case 3:// facing west
			if(maze[robRow][robCol].wWall == 1){
				turnLeft();
				continue;
			}
			break;
		default: break;
		}
		goFwd();
		directionLog[stepCounter] = robHeading;//creates a log of direction data
		stepCounter++;
		turnRight();
	}
	robRow = startRow;
	robCol = startcol;
	robHeading = 0;
	refreshScreen();
	simplifyMaze();
	turnRight();
	startMove();
}
void MazeSim(){//builds the maze that is to be solved
	maze[0][0].eWall = maze[0][1].wWall = 1;
	maze[0][1].eWall = maze[0][2].wWall = 1;
	maze[0][2].eWall = maze[0][3].wWall = 1;
	maze[0][3].eWall = maze[0][4].wWall = 1;
	maze[0][4].eWall = maze[0][5].wWall = 1;
	maze[0][5].eWall = maze[0][6].wWall = 1;
	maze[0][6].eWall = maze[0][7].wWall = 1;
	maze[1][1].eWall = maze[1][2].wWall = 1;
	maze[1][2].eWall = maze[1][3].wWall = 1;
	maze[1][4].eWall = maze[1][5].wWall = 1;
	maze[1][5].eWall = maze[1][6].wWall = 1;
	maze[3][1].eWall = maze[3][2].wWall = 1;
	maze[3][2].eWall = maze[3][3].wWall = 1;
	maze[3][4].eWall = maze[3][5].wWall = 1;
	maze[3][5].eWall = maze[3][6].wWall = 1;
	maze[3][6].eWall = maze[3][7].wWall = 1;
	maze[4][0].eWall = maze[4][1].wWall = 1;
	maze[4][3].eWall = maze[4][4].wWall = 1;
	maze[4][4].eWall = maze[4][5].wWall = 1;
	maze[4][5].eWall = maze[4][6].wWall = 1;
	maze[5][1].eWall = maze[5][2].wWall = 1;
	maze[5][2].eWall = maze[5][3].wWall = 1;
	maze[5][4].eWall = maze[5][5].wWall = 1;
	maze[5][5].eWall = maze[5][6].wWall = 1;
	maze[5][6].eWall = maze[5][7].wWall = 1;
	maze[6][4].eWall = maze[6][5].wWall = 1;
	maze[6][5].eWall = maze[6][6].wWall = 1;
	maze[7][6].eWall = maze[7][7].wWall = 1;
	maze[8][0].eWall = maze[8][1].wWall = 1;
	maze[8][1].eWall = maze[8][2].wWall = 1;
	maze[8][2].eWall = maze[8][3].wWall = 1;
	maze[8][4].eWall = maze[8][5].wWall = 1;
	maze[8][6].eWall = maze[8][7].wWall = 1;
	maze[9][0].eWall = maze[9][1].wWall = 1;
	maze[9][3].eWall = maze[9][4].wWall = 1;
	maze[9][4].eWall = maze[9][5].wWall = 1;
	maze[9][5].eWall = maze[9][6].wWall = 1;
	maze[9][6].eWall = maze[9][7].wWall = 1;
	maze[0][1].nWall = maze[1][1].sWall = 1;
	maze[0][3].nWall = maze[1][3].sWall = 1;
	maze[0][6].nWall = maze[1][6].sWall = 1;
	maze[1][0].nWall = maze[2][0].sWall = 1;
	maze[1][4].nWall = maze[2][4].sWall = 1;
	maze[1][7].nWall = maze[2][7].sWall = 1;
	maze[2][0].nWall = maze[3][0].sWall = 1;
	maze[2][1].nWall = maze[3][1].sWall = 1;
	maze[2][4].nWall = maze[3][4].sWall = 1;
	maze[2][7].nWall = maze[3][7].sWall = 1;
	maze[3][1].nWall = maze[4][1].sWall = 1;
	maze[3][3].nWall = maze[4][3].sWall = 1;
	maze[3][7].nWall = maze[4][7].sWall = 1;
	maze[4][0].nWall = maze[5][0].sWall = 1;
	maze[4][3].nWall = maze[5][3].sWall = 1;
	maze[4][6].nWall = maze[5][6].sWall = 1;
	maze[5][0].nWall = maze[6][0].sWall = 1;
	maze[5][1].nWall = maze[6][1].sWall = 1;
	maze[5][2].nWall = maze[6][2].sWall = 1;
	maze[5][3].nWall = maze[6][3].sWall = 1;
	maze[5][6].nWall = maze[6][6].sWall = 1;
	maze[5][7].nWall = maze[6][7].sWall = 1;
	maze[6][0].nWall = maze[7][0].sWall = 1;
	maze[6][1].nWall = maze[7][1].sWall = 1;
	maze[6][2].nWall = maze[7][2].sWall = 1;
	maze[6][3].nWall = maze[7][3].sWall = 1;
	maze[6][4].nWall = maze[7][4].sWall = 1;
	maze[7][0].nWall = maze[8][0].sWall = 1;
	maze[7][1].nWall = maze[8][1].sWall = 1;
	maze[7][3].nWall = maze[8][3].sWall = 1;
	maze[7][4].nWall = maze[8][4].sWall = 1;
	maze[7][6].nWall = maze[8][6].sWall = 1;
	maze[8][4].nWall = maze[9][4].sWall = 1;
	maze[8][6].nWall = maze[9][6].sWall = 1;
}
void refreshScreen(){//drawing the maze and bots current positions
	eraseDisplay();
	gridDraw();
	drawBot();
}
void goFwd(){
	refreshScreen();
	wait1Msec(100); // waste some time to simulate motion
	if (robHeading==0) { // Going Fwd North
		robRow++;
	}
	else if (robHeading==1) { // Going Fwd East
		robCol++;
	}
	else if (robHeading==2) { // Going Fwd South
		robRow--;
	}
	else if (robHeading==3) { // Going Fwd West
		robCol--;
	}
	else {
		robRow = 99;
		robCol = 99;
	}
}
void turnRight(){
	refreshScreen();
	if (robHeading < 3){
		robHeading++;
	}
	else robHeading=0;
}
void turnLeft(){
	refreshScreen();
	if (robHeading > 0){
		robHeading--;
	}
	else robHeading=3;
}
void buildOuterBorders(){
	for(int col=0; col<numOfCols; col++){
		maze[0][col].sWall = 1;
		maze[numOfRows-1][col].nWall = 1;
	}
	for(int row=0; row<numOfRows; row++){
		maze[row][0].wWall = 1;
		maze[row][numOfCols-1].eWall = 1;
	}
}
//=====================================================================
void gridDraw(){
	int XStart=0;
	int YStart=0;
	int XEnd =0;
	int YEnd =0;
	for(int i=0;i<numOfRows;i++){
		for(int j=0;j<numOfCols;j++){
			if(maze[i][j].nWall==1){
				XStart= j *screenWidth/numOfCols;
				YStart=(i+1)*screenHeight/numOfRows;
				XEnd =(j+1)*screenWidth/numOfCols;
				YEnd =(i+1)*screenHeight/numOfRows;
				drawLine(XStart,YStart,XEnd,YEnd);
			}
			if (maze[i][j].eWall==1){
				XStart=(j+1)*screenWidth/numOfCols;
				YStart=(i)*screenHeight/numOfRows;
				XEnd =(j+1)*screenWidth/numOfCols;
				YEnd =(i+1)*screenHeight/numOfRows;
				drawLine(XStart,YStart,XEnd,YEnd);
			}
			if (maze[i][j].wWall==1){
				XStart= j *screenWidth/numOfCols;
				YStart=(i)*screenHeight/numOfRows;
				XEnd =(j)*screenWidth/numOfCols;
				YEnd =(i+1)*screenHeight/numOfRows;
				drawLine(XStart,YStart,XEnd,YEnd);
			}
			if(maze[i][j].sWall==1){
				XStart= j *screenWidth/numOfCols;
				YStart=(i)*screenHeight/numOfRows;
				XEnd =(j+1)*screenWidth/numOfCols;
				YEnd =(i)*screenHeight/numOfRows;
				drawLine(XStart,YStart,XEnd,YEnd);
			}
		}
	}
}
//=====================================================================
void drawBot(){
	int RobotXpixelPos=0;
	int RobotYpixelPos=0;
	if(robCol==0){
		RobotXpixelPos=screenWidth/16;
	}
	else{
		RobotXpixelPos=(2*robCol+1)*screenWidth/16;
	}
	if(robRow==0){
		RobotYpixelPos=screenHeight/20;
	}
	else{
		RobotYpixelPos=(2*robRow+1)*screenHeight/20;
	}
	switch(robHeading){
	case 0: displayStringAt(RobotXpixelPos,RobotYpixelPos,"^");
		break; // Facing North
	case 1: displayStringAt(RobotXpixelPos,RobotYpixelPos,">");
		break; // Facing East
	case 2: displayStringAt(RobotXpixelPos,RobotYpixelPos,"V");
		break; // Facing South
	case 3: displayStringAt(RobotXpixelPos,RobotYpixelPos,"<");
		break; // Facing West
	default: break;
	}
}
// We assign the useless array values to -1...
// if directions are opposite (E W), or (N S)...
// assign those direction log to -1
void simplifyMaze(){
	int begin_index;
	int end_index;
	int i = 0;

	while(i < stepCounter){
		if(directionLog[i] == -1){
			if(i == 0){
				begin_index = i;
			}
			else{
				begin_index = i-1;
			}
			while(directionLog[i] == -1){
				i++;
			}
			end_index = i;
			if(abs(directionLog[begin_index]-directionLog[end_index]) == 2){
				directionLog[begin_index] = -1;
				directionLog[end_index] = -1;
				i = 0;
			}
			else if(begin_index == 0 && abs(directionLog[end_index]-directionLog[end_index+1]) == 2){
				directionLog[end_index] = -1;
				directionLog[end_index+1] = -1;
				i = 0;
			}
		}
		else if(abs(directionLog[i]-directionLog[i+1]) == 2){
			if(i == 0 && directionLog[i+1] != -1){
				directionLog[i] = -1;
				directionLog[i+1] = -1;
				i = 0;
			}
			else if(i != 0 && directionLog[i+1] != -1){
				directionLog[i] = -1;
				directionLog[i+1] = -1;
				i = 0;
			}
			else{
				i++;
			}
		}
		else{
			i++;
		}
	}
}
//ignores the -ve values and goes by the +ve directionLogs
void startMove(){
	// Going by using the shortest path
	for(int i = 0; i < stepCounter; i++){
		if(directionLog[i] >= 0){
			while(directionLog[i] != robHeading){
				if(directionLog[i] > robHeading && directionLog[i] - robHeading != 3){
					turnRight();
				}
				else{
					turnLeft();
				}
			}
			goFwd();
		}
	}
}
